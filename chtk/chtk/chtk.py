from tkinter import W
from librosa import load, resample, power_to_db
from librosa.feature import melspectrogram
import numpy as np
import pandas as pd
from pathlib import Path
import os
import warnings
from dataclasses import dataclass, field
from typing import List
from numpy import ndarray
from .chart import chart_to_array
from .visualization import plot_chart
from .constants import SIMPLIFIED_NOTE_DICT

# ---------------------------------------------------------------------------- #
#                                 data classes                                 #
# ---------------------------------------------------------------------------- #

class SongDataset:
    '''
    NOTE:
    Reorganize this so that the core data structure consists of Song objects.
    Make a method that allows you to get a dataframe from it.
    
    If pandas DataFrame is your main data structure, you could really screw
    yourself down the line
    '''
    def __init__(self, 
                 directory: Path,
                 fill_notes_array: bool = True,
                 fill_audio: bool = False):

        song_paths = [Path((p,_)[0]) 
                      for p,_ in self.parse_chart_files(directory)]

        data = []
        for song in song_paths:
            s = Song(song)
            if fill_notes_array:
                if s.chart_format == '.chart':
                    s.fill_notes_array()
                else:
                    warnings.warn(f'.mid chart files detected at {s.chart_file}')
            if fill_audio:
                s.fill_audio()
            data.append(s)
        
        self.df = pd.DataFrame(data)    
        
    def parse_chart_files(self, root):
        chart_suffixes = ['.chart', '.mid']
        for path, _, files in os.walk(root):
            yield from ((path, file) for file in files 
                        if Path(file).suffix in chart_suffixes)

@dataclass
class Song:
    '''Holds all relevant data and information about a single song
    '''
    directory: Path

    # These parameters are generated by the __post_init__ method
    name: str = field(default=None)
    config: dict = field(default=None)
    chart_format: str = field(default=None)
    chart_file: Path = field(default=None)
    config_file: Path = field(default=None)
    audio_files: List[Path] = field(default_factory=list)
    image_files: List[Path] = field(default_factory=list)
    misc_files: List[Path] = field(default_factory=list)
    multiple_audios: bool = field(default=None)

    # These parameters require some computation will only be filled by calling
    # their respective methods
    # fill_notes()
    notes_array: ndarray = field(default=None)
    simplified_notes_array: ndarray = field(default=None)

    # fill_audio()
    audio: ndarray = field(default=None)
    sr: int = field(default=None)
    
    def __post_init__(self) -> None:
        '''Populates song data and information from files at directory'''
        

        # Get file paths, check if multiple audio files, get chart format
        audio_suffixes = ['.mp3', '.wav', '.ogg']
        chart_suffixes = ['.chart', '.mid']
        config_suffix = '.ini'
        image_suffixes = ['.png', '.jpg']
        
        for f in [self.directory / x for x in os.listdir(self.directory)]:
            if f.suffix in audio_suffixes:
                self.audio_files.append(f)
            elif f.suffix in image_suffixes:
                self.image_files.append(f)
            elif f.suffix in chart_suffixes:
                self.chart_file = f
            elif f.suffix == config_suffix:
                self.config_file = f
            else:
                self.misc_files.append(f)
        
        self.multiple_audios = True if len(self.audio_files) > 1 else False
        if self.chart_file.suffix == '.chart':
            self.chart_format = '.chart'
        else:
            self.chart_format = '.ini'
        
        # Get configuration
        with open(self.config_file, 'r') as f:
            lines = f.read().splitlines()
        
        self.config = {}
        for line in lines:
            if '=' not in line:  # ignore [song] line
                continue
            kv = line.split(' = ')
            if kv[1].lstrip('-').isdigit(): # if value is integer
                kv[1] = int(kv[1])
            elif kv[1].strip('-').strip('.').isdigit(): # if value is float
                kv[1] = float(kv[1])
            self.config[kv[0]] = kv[1]

        # self.name comes from config file rather than folder name
        self.name = self.config['name']


    def fill_notes_array(self) -> None:
        self.notes_array = chart_to_array(self.chart_file)
        self.simplified_notes_array = simplify_notes_array(self.notes_array)
    
    def fill_audio(self) -> None:
        if self.multiple_audios:
            warnings.warn('Multiple audio support is implemented yet')
        else: 
            self.audio, self.sr = load_audio(self.audio_files[0])
    
    def visualize(self, start=None, end=None):
        
        # Display 200 ticks by default 
        if start is not None and end is None:
            end = start + 200
        if end is not None and start is None:
            start = max(end-200, 0)

        plot_chart(self.notes_array[start:end])
        
         
        
# ---------------------------------------------------------------------------- #
#                                 PREPROCESSING                                #
# ---------------------------------------------------------------------------- #


def load_song(song_dir):
    '''Loads audio, sr, and notes array from song_dir, returns audio and notes 
    array sliced into 4 second chunks

    Args:
        song_dir (Path): Path to song directory containing both notes.chart and 
        other.wav
    
    Returns:
        notes_arrays (2D numpy array): Matrix of numpy arrays where each row is 
            a 4 second notes array
        audio_segments (2D numpy array): Matrix of raw audio arrays where each 
            row is 4 seconds of audio
        sr (int): sample rate
    '''
    # Get simplified notes array and audio
    notes_array = chart_to_array(song_dir / 'notes.chart')
    notes_array = __remove_modifiers(__remove_release_keys(notes_array))
    audio, sr = load(str(song_dir / 'other.wav'))
 
    return notes_array, audio, sr


def load_audio(path):
    return load(str(path))


def compute_mel_spectrogram(song_path):
    '''
    Computes the log-mel spectrogram of a .ogg file

    Args:
        song_path (str | Path): path to .ogg file
    
    Returns:
        spec (2D numpy array): log-mel spectrogram
        -   dimensions = [frequency, time], frequency dimension is always 512
        -   each time slice represents 10 milliseconds
        -   log-scale, so max(spec) = 0, min(spec) = -80
    '''
    audio, sr = load(str(song_path))
    resampled = resample(audio, orig_sr=sr, target_sr=44100)
    spec = melspectrogram(y=resampled, sr=44100, n_fft=2048*2, hop_length=441, 
                          n_mels=512, power=2, fmax = sr/2)
    spec = power_to_db(spec, ref=np.max)
    return spec


def simplify_notes_array(notes_array):
    '''
    Removes all modifiers and released notes from a notes array.

    Args:
        notes_array (1D numpy array): notes array with modifiers and released
            notes one hot encoded

    Returns:
        simplified_notes_array (1D numpy array): notes array with released notes
            removed and modifiers changed from held or tapped to regular.
    '''
    notes_array = __remove_modifiers(__remove_release_keys(notes_array))
    return notes_array.astype(np.uint8)

    
# ---------------------------------------------------------------------------- #
#                               HELPER FUNCTIONS                               #
# ---------------------------------------------------------------------------- #


def __remove_release_keys(notes_array):
    '''
    Removes all notes corresponding to releases from notes_array
   
    Args:
        notes_array (1D numpy array): notes array including release keys
   
    Returns:
        1D numpy array: new notes array with release keys removed (converted to zeros)
    '''
    new_notes = np.zeros(notes_array.size)
    changed_notes = []
    for x in range(notes_array.size):
        if notes_array[x] not in list(range(187,218)):
            new_notes[x] = notes_array[x]
        else:
            changed_notes.append(x)
    return new_notes


def __remove_modifiers(notes_array):
    '''
    Maps modified and held notes to their regular counterparts

    Args:
        notes_array (1D numpy array): any notes array
    '''
    new_notes = np.zeros(notes_array.size)
    for x in range(notes_array.size):
        if notes_array[x]:
            new_notes[x] = SIMPLIFIED_NOTE_DICT[notes_array[x]]
    return new_notes

if __name__ == '__main__':
    data_dir = Path.cwd() / 'tests' / 'data'
    
    # p = data_dir / 'song_0'

    # song = Song(p)
    # song.fill_notes_array()
    # song.fill_simplified_notes_array()
    # song.fill_audio()

    # print(song)
    # print(song.__dict__)

    dataset = SongDataset(data_dir)
    print(dataset.df.head())