from tkinter import W
from librosa import load, resample, power_to_db
from librosa.feature import melspectrogram
import numpy as np
import pandas as pd
from pathlib import Path
import os
import warnings
from dataclasses import dataclass, field
from typing import List
from numpy import ndarray

try:
    from .chart import chart_to_array
    from .visualization import plot_chart
    from .constants import SIMPLIFIED_NOTE_DICT
except ImportError as err:
    import warnings
    warnings.warn(
        f'Replacing "import .package" with "import package"', ImportWarning
        )
    from chart import chart_to_array
    from visualization import plot_chart
    from constants import SIMPLIFIED_NOTE_DICT


class TrackPack:
    '''
    NOTE:
    Reorganize this so that the core data structure consists of Song objects.
    Make a method that allows you to get a dataframe from it.
    
    If pandas DataFrame is your main data structure, you could really screw
    yourself down the line
    '''
    def __init__(self, 
                 directory: Path,
                 fill_notes_array: bool = True,
                 fill_audio: bool = False,
                 fill_spectrogram: bool = False):
        '''

        Args:
            directory (Path): Top level track pack
            fill_notes_array (bool, optional): _description_. Defaults to True.
            fill_audio (bool, optional): _description_. Defaults to False.
            fill_spectrogram (bool, optional): _description_. Defaults to False.
        '''

        song_paths = [Path((p,_)[0]) 
                      for p,_ in self.parse_chart_files(directory)]

        data = []
        for song in song_paths:
            s = Song(song)
            if fill_notes_array:
                if s.chart_format == '.chart':
                    s.fill_notes()
                else:
                    warnings.warn(f'.mid chart files detected at {s.chart_file}')
            if fill_audio:
                s.fill_audio()
            if fill_spectrogram:
                s.fill_spectrogram()
            data.append(s)
        
        self.df = pd.DataFrame(data)    
        
    def parse_chart_files(self, root):
        chart_suffixes = ['.chart', '.mid']
        for path, _, files in os.walk(root):
            yield from ((path, file) for file in files 
                        if Path(file).suffix in chart_suffixes)

@dataclass
class Song:
    '''Holds all relevant data and information about a single song.
    
    Args:
        directory (Path or str): Path to a directory holding a clone hero song. 
            Each song is packaged into a folder containing the audio files, the
            chart file, etc.
    
    Auto-Filled Parameters: 
    (Populated upon class instantation by __post_init__())
        name (str): The name of the song, gathered from the config file rather
            than the directory name
        config (dict): All the parameters in the configuration file. See song
            files with .ini extension for examples.
        chart_format (str): The extension of the chart file. Either ".chart" or
            ".mid" depending on whether the chart is in chart or midi format.
        chart_file (Path): The path to the chart file.
        config_file (Path): The path to the config file
        audio_files (List[Path]): A list of paths to all audio files in 
            directory. Sometimes the audio comes in parts like "guitar.ogg" and
            "drums.ogg", etc.
        image_files (List[Path]): All the image files present in directory
        misc_files (List[Path]): Any other file in the directory not fitting
            into any of the previous categories
        multiple_audios (bool): True if more than one audio file is present in
            directory, False otherwise.
        directory (Path): The path to the 
        
    Manual Parameters:
    (Populated manually by calling class functions)
        notes (ndarray): shape = (<song length in seconds>*100)
            An array representing 10ms time bins in the song. If a note is
            present in a bin, it is populated with it's one hot encoding.
            Otherwise, a 0 is present. See docs for one hot encoding key.
        simple_notes (ndarray): shape = (<song length in seconds>*100)
            A derivative of notes with certain descriptive modifiers removed.
            See docs for details.
        audio (ndarray): shape = (<song length in seconds>*<sample rate>)
            A raw representation of the audio waveform. Note this cannot be
            computed if there are multiple audio files.
        sr (int): The sample rate of audio
        spectrogram (ndarray): shape depends on the parameters of the 
            spectrogram computation. 
            Defaults to:
                shape = (512, <song length in seconds>*100)
        spectrogram_file (Path): Path to spectrogram saved within directory.
    '''
    # args
    directory: Path | str

    # These parameters are generated by the __post_init__ method
    name: str = field(default=None)
    config: dict = field(default=None)
    chart_format: str = field(default=None)
    chart_file: Path = field(default=None)
    config_file: Path = field(default=None)
    audio_files: List[Path] = field(default_factory=list)
    image_files: List[Path] = field(default_factory=list)
    misc_files: List[Path] = field(default_factory=list)
    multiple_audios: bool = field(default=None)

    # These parameters require some computation will only be filled by calling
    # their respective methods
    # fill_notes()
    notes: ndarray = field(default=None)
    simple_notes: ndarray = field(default=None)
    # fill_audio()
    audio: ndarray = field(default=None)
    sr: int = field(default=None)
    # fill_spectrogram()
    spectrogram: ndarray = field(default=None)
    spectrogram_file: Path = field(default=None)
    

    def __post_init__(self) -> None:
        '''Populates class parameters from files in directory
        '''
        # Convert directory to path if it is a string
        if type(self.directory) == str:
            self.directory = Path(self.directory)

        # Get file paths, check if multiple audio files, get chart format
        audio_suffixes = ['.mp3', '.wav', '.ogg']
        chart_suffixes = ['.chart', '.mid']
        config_suffix = '.ini'
        image_suffixes = ['.png', '.jpg']
        
        for f in [self.directory / x for x in os.listdir(self.directory)]:
            if f.suffix in audio_suffixes:
                self.audio_files.append(f)
            elif f.suffix in image_suffixes:
                self.image_files.append(f)
            elif f.suffix in chart_suffixes:
                self.chart_file = f
            elif f.suffix == config_suffix:
                self.config_file = f
            else:
                self.misc_files.append(f)
        
        self.multiple_audios = True if len(self.audio_files) > 1 else False
        if self.chart_file.suffix == '.chart':
            self.chart_format = '.chart'
        else:
            self.chart_format = '.mid'
        
        # Get configuration parameters from config file
        with open(self.config_file, 'r') as f:
            lines = f.read().splitlines()
        
        self.config = {}
        for line in lines:
            if '=' not in line:  # ignore [song] line
                continue
            kv = line.split(' = ')
            if kv[1].lstrip('-').isdigit(): # if value is integer
                kv[1] = int(kv[1])
            elif kv[1].strip('-').strip('.').isdigit(): # if value is float
                kv[1] = float(kv[1])
            self.config[kv[0]] = kv[1]

        # self.name comes from config file rather than folder name
        self.name = self.config['name']


    def fill_notes(self) -> None:
        self.notes = chart_to_array(self.chart_file)
        self.simple_notes = simplify_notes_array(self.notes)
    

    def fill_audio(self) -> None:
        if self.multiple_audios:
            warnings.warn('Multiple audio support is not implemented yet, \
                filling with first audio in directory.')
        else: 
            self.audio, self.sr = load(str(self.audio_files[0]))
    

    def fill_spectrogram(self, 
                         n_fft: int = 4096, 
                         hop_length:int = 441, 
                         n_mels: int = 512, 
                         power: int = 2,
                         fmax: int = None) -> None:
        '''Computes the log-mel spectrogram from an audio file
        '''
        
        if self.audio is None or self.sr is None:
            self.fill_audio()
        if fmax is None:
            fmax = self.sr/2
        
        if self.sr == 44100:
            self.specrogram = melspectrogram(self.audio, 44100, 
                                             n_fft=n_fft, 
                                             hop_length=hop_length, 
                                             n_mels=n_mels, 
                                             power=power)
        else:
            resampled = resample(self.audio, 
                                 orig_sr=self.sr, 
                                 target_sr=44100)
            self.spectrogram = melspectrogram(y=resampled, 
                                              sr=44100, 
                                              n_fft=n_fft, 
                                              hop_length=hop_length, 
                                              n_mels=n_mels, 
                                              power=power)
        self.spectrogram = power_to_db(self.spectrogram, ref=np.max)
    

    def plot(self, start=None, end=None, show=False):
        '''Generates a quick plot of the chart

        Args:
            start (_type_, optional): _description_. Defaults to None.
            end (_type_, optional): _description_. Defaults to None.
        '''
        if self.spectrogram is None:
            self.fill_spectrogram()

        # Display 200 ticks by default 
        if start is not None and end is None:
            end = start + 200
        elif end is not None and start is None:
            start = end - 200
        elif start is None and end is None:
            start, end = 0, 200

        plot_chart(self.notes[start:end], audio=self.spectrogram[:, start:end])

        
# ---------------------------------------------------------------------------- #
#                                 PREPROCESSING                                #
# ---------------------------------------------------------------------------- #


def load_song(song_dir):
    '''Loads audio, sr, and notes array from song_dir, returns audio and notes 
    array sliced into 4 second chunks

    Args:
        song_dir (Path): Path to song directory containing both notes.chart and 
        other.wav
    
    Returns:
        notes_arrays (2D numpy array): Matrix of numpy arrays where each row is 
            a 4 second notes array
        audio_segments (2D numpy array): Matrix of raw audio arrays where each 
            row is 4 seconds of audio
        sr (int): sample rate
    '''
    # Get simplified notes array and audio
    notes_array = chart_to_array(song_dir / 'notes.chart')
    notes_array = remove_modifiers(remove_release_keys(notes_array))
    audio, sr = load(str(song_dir / 'other.wav'))
 
    return notes_array, audio, sr


def compute_mel_spectrogram(song_path):
    '''
    Computes the log-mel spectrogram of a .ogg file

    Args:
        song_path (str | Path): path to .ogg file
    
    Returns:
        spec (2D numpy array): log-mel spectrogram
        -   dimensions = [frequency, time], frequency dimension is always 512
        -   each time slice represents 10 milliseconds
        -   log-scale, so max(spec) = 0, min(spec) = -80
    '''
    audio, sr = load(str(song_path))
    resampled = resample(audio, orig_sr=sr, target_sr=44100)
    spec = melspectrogram(y=resampled, sr=44100, n_fft=2048*2, hop_length=441, 
                          n_mels=512, power=2, fmax = sr/2)
    spec = power_to_db(spec, ref=np.max)
    return spec

# ---------------------------------------------------------------------------- #
#                              note simplification                             #
# ---------------------------------------------------------------------------- #

def simplify_notes_array(notes_array):
    '''
    Removes all modifiers and released notes from a notes array.

    Args:
        notes_array (1D numpy array): notes array with modifiers and released
            notes one hot encoded

    Returns:
        simplified_notes_array (1D numpy array): notes array with released notes
            removed and modifiers changed from held or tapped to regular.
    '''
    notes_array = remove_modifiers(remove_release_keys(notes_array))
    return notes_array.astype(np.uint8)

    
def remove_release_keys(notes_array):
    '''
    Removes all notes corresponding to releases from notes_array
   
    Args:
        notes_array (1D numpy array): notes array including release keys
   
    Returns:
        1D numpy array: new notes array with release keys removed (converted to zeros)
    '''
    new_notes = np.zeros(notes_array.size)
    changed_notes = []
    for x in range(notes_array.size):
        if notes_array[x] not in list(range(187,218)):
            new_notes[x] = notes_array[x]
        else:
            changed_notes.append(x)
    return new_notes


def remove_modifiers(notes_array):
    '''
    Maps modified and held notes to their regular counterparts

    Args:
        notes_array (1D numpy array): any notes array
    '''
    new_notes = np.zeros(notes_array.size)
    for x in range(notes_array.size):
        if notes_array[x]:
            new_notes[x] = SIMPLIFIED_NOTE_DICT[notes_array[x]]
    return new_notes

# For testing, this is quick and dirty
if __name__ == '__main__':
    data_dir = Path.cwd() / 'chtk' / 'tests' / 'data'
    
    p = data_dir / 'song_0'

    song = Song(p)
    song.fill_notes()
    song.fill_audio()
    song.fill_spectrogram()

    print(f'song.__dict__: {song.__dict__}')

    dataset = SongDataset(data_dir)
    print(dataset.df.head())
    print(dataset.df.columns)
